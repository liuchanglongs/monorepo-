<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多文件上传带动态任务调度</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        danger: '#EF4444',
                        neutral: '#64748B'
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .file-progress {
                @apply h-2 bg-gray-200 rounded-full overflow-hidden;
            }
            .file-progress-bar {
                @apply h-full bg-primary transition-all duration-300 ease-out;
            }
            .upload-item {
                @apply p-4 border border-gray-200 rounded-lg mb-3 bg-white shadow-sm hover:shadow-md transition-shadow;
            }
        }
    </style>
</head>

<body class="bg-gray-50 font-inter text-gray-800 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <header class="mb-8 text-center">
            <h1 class="text-[clamp(1.8rem,4vw,2.5rem)] font-bold text-gray-800 mb-2">多文件上传器</h1>
            <p class="text-neutral">支持同时上传3个文件，自动调度空闲资源加速大文件处理</p>
        </header>

        <div class="bg-white rounded-xl shadow-md p-6 mb-8">
            <div class="flex flex-col md:flex-row gap-4 items-center">
                <label for="file-upload"
                    class="flex-1 bg-primary hover:bg-primary/90 text-white py-3 px-6 rounded-lg transition-colors cursor-pointer text-center">
                    <i class="fa fa-cloud-upload mr-2"></i>选择文件
                </label>
                <input id="file-upload" type="file" multiple class="hidden" />

                <button id="start-upload"
                    class="bg-secondary hover:bg-secondary/90 text-white py-3 px-6 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    <i class="fa fa-play mr-2"></i>开始上传
                </button>
            </div>

            <div id="file-list" class="mt-6 space-y-3 max-h-[500px] overflow-y-auto pr-2">
                <!-- 文件列表将动态插入这里 -->
                <div class="text-neutral text-center py-8 border-2 border-dashed rounded-lg" id="empty-state">
                    <i class="fa fa-file-o text-4xl mb-3 opacity-40"></i>
                    <p>未选择任何文件</p>
                </div>
            </div>
        </div>

        <div class="bg-white rounded-xl shadow-md p-6">
            <h2 class="text-lg font-semibold mb-4 flex items-center">
                <i class="fa fa-info-circle text-primary mr-2"></i>上传状态
            </h2>
            <div id="upload-status" class="text-sm text-neutral">
                等待开始上传...
            </div>
        </div>
    </div>

    <!-- Hash计算Worker脚本 -->
    <script id="hash-worker-script" type="javascript/worker">
        // 分块计算文件的MD5哈希
        self.onmessage = function(e) {
            const { fileId, chunk, chunkIndex } = e.data;
            
            // 使用SubtleCrypto API计算哈希（比纯JS实现快很多）
            const fileReader = new FileReader();
            
            fileReader.onload = function(event) {
                const arrayBuffer = event.target.result;
                
                crypto.subtle.digest('MD5', arrayBuffer)
                    .then(hashBuffer => {
                        // 将ArrayBuffer转换为十六进制字符串
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                        
                        // 发送计算结果回主线程
                        self.postMessage({
                            fileId,
                            chunkIndex,
                            hash: hashHex
                        });
                    })
                    .catch(error => {
                        self.postMessage({
                            fileId,
                            chunkIndex,
                            error: error.message
                        });
                    });
            };
            
            fileReader.readAsArrayBuffer(chunk);
        };
    </script>

    <script>
        // 上传配置
        const UPLOAD_CONFIG = {
            maxConcurrentWorkers: 3,    // 最大并发Worker数量
            chunkSize: 4 * 1024 * 1024, // 分块大小4MB
            simulateUpload: true        // 模拟上传（实际项目中设为false）
        };

        // 全局状态
        const state = {
            files: [],                  // 待上传文件列表
            fileChunks: new Map(),      // 文件分块映射: fileId -> { total: number, chunks: Array, results: Map }
            taskQueue: [],              // 任务队列
            activeWorkers: 0,           // 活跃Worker数量
            workers: [],                // Worker实例数组
            isUploading: false          // 是否正在上传
        };

        // DOM元素
        const elements = {
            fileInput: document.getElementById('file-upload'),
            startButton: document.getElementById('start-upload'),
            fileList: document.getElementById('file-list'),
            emptyState: document.getElementById('empty-state'),
            uploadStatus: document.getElementById('upload-status')
        };

        // 初始化
        function init() {
            // 监听文件选择
            elements.fileInput.addEventListener('change', handleFileSelection);

            // 监听开始上传按钮
            elements.startButton.addEventListener('click', startUpload);

            // 禁用开始按钮直到有文件
            elements.startButton.disabled = true;

            // 创建Worker脚本URL
            const workerScript = document.getElementById('hash-worker-script').textContent;
            window.workerBlobUrl = URL.createObjectURL(
                new Blob([workerScript], { type: 'application/javascript' })
            );
        }

        // 处理文件选择
        function handleFileSelection(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            // 清空空状态提示
            elements.emptyState.classList.add('hidden');

            // 添加文件到状态并渲染
            files.forEach(file => {
                const fileId = `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                state.files.push({
                    id: fileId,
                    name: file.name,
                    size: file.size,
                    file: file,
                    progress: 0,
                    status: 'pending', // pending, processing, uploading, completed, error
                    hash: null,
                    error: null
                });

                // 拆分文件为块
                splitFileIntoChunks(file, fileId);

                // 渲染文件项
                renderFileItem(state.files[state.files.length - 1]);
            });

            // 启用开始按钮
            elements.startButton.disabled = false;

            // 重置文件输入，允许重复选择相同文件
            elements.fileInput.value = '';
        }

        // 将文件拆分为块
        function splitFileIntoChunks(file, fileId) {
            const chunks = [];
            const totalChunks = Math.ceil(file.size / UPLOAD_CONFIG.chunkSize);

            for (let i = 0; i < totalChunks; i++) {
                const start = i * UPLOAD_CONFIG.chunkSize;
                const end = Math.min(start + UPLOAD_CONFIG.chunkSize, file.size);
                const chunk = file.slice(start, end);

                chunks.push({
                    index: i,
                    data: chunk,
                    processed: false,
                    hash: null
                });
            }

            state.fileChunks.set(fileId, {
                total: totalChunks,
                chunks: chunks,
                completedChunks: 0,
                results: new Map() // 存储计算完成的块哈希: chunkIndex -> hash
            });
        }

        // 渲染文件项
        function renderFileItem(file) {
            const fileItem = document.createElement('div');
            fileItem.id = `file-item-${file.id}`;
            fileItem.className = 'upload-item';

            // 格式化文件大小
            const fileSize = formatFileSize(file.size);

            fileItem.innerHTML = `
                <div class="flex justify-between items-start mb-2">
                    <div>
                        <div class="font-medium flex items-center">
                            <i class="fa fa-file-o text-primary mr-2"></i>
                            <span class="truncate max-w-[200px] md:max-w-[400px]">${file.name}</span>
                        </div>
                        <div class="text-sm text-neutral mt-1">${fileSize} · ${getFileStatusText(file.status)}</div>
                    </div>
                    <div class="text-sm ${getStatusColorClass(file.status)}">
                        ${file.error ? `<i class="fa fa-exclamation-circle"></i> 错误` : ''}
                    </div>
                </div>
                <div class="file-progress">
                    <div class="file-progress-bar" style="width: ${file.progress}%"></div>
                </div>
                <div class="mt-2 text-xs text-neutral hidden" id="hash-${file.id}">
                    哈希计算中...
                </div>
            `;

            elements.fileList.appendChild(fileItem);
        }

        // 更新文件状态
        function updateFileStatus(fileId, updates) {
            const file = state.files.find(f => f.id === fileId);
            if (!file) return;

            // 应用更新
            Object.assign(file, updates);

            // 更新DOM
            const fileItem = document.getElementById(`file-item-${fileId}`);
            if (!fileItem) return;

            // 更新进度条
            const progressBar = fileItem.querySelector('.file-progress-bar');
            progressBar.style.width = `${file.progress}%`;

            // 更新状态文本
            const statusText = fileItem.querySelector('.text-neutral');
            statusText.innerHTML = `${formatFileSize(file.size)} · ${getFileStatusText(file.status)}`;

            // 更新状态标签
            const statusLabel = fileItem.querySelector('.text-sm:last-child');
            statusLabel.className = `text-sm ${getStatusColorClass(file.status)}`;
            statusLabel.innerHTML = file.error ? `<i class="fa fa-exclamation-circle"></i> 错误` : '';

            // 显示哈希结果
            if (file.hash) {
                const hashElement = document.getElementById(`hash-${fileId}`);
                hashElement.classList.remove('hidden');
                hashElement.textContent = `文件哈希: ${file.hash.substring(0, 16)}...`;
            }
        }

        // 开始上传流程
        function startUpload() {
            if (state.isUploading || state.files.length === 0) return;

            state.isUploading = true;
            elements.startButton.disabled = true;
            elements.startButton.innerHTML = '<i class="fa fa-spinner fa-spin mr-2"></i>上传中...';

            updateStatus('开始处理文件...');

            // 初始化任务队列
            initTaskQueue();

            // 启动Worker
            startWorkers();
        }

        // 初始化任务队列
        function initTaskQueue() {
            state.taskQueue = [];

            // 为每个文件的每个块创建任务
            state.files.forEach(file => {
                const fileData = state.fileChunks.get(file.id);
                if (!fileData) return;

                fileData.chunks.forEach(chunk => {
                    state.taskQueue.push({
                        fileId: file.id,
                        chunkIndex: chunk.index,
                        chunk: chunk.data
                    });
                });

                // 更新文件状态
                updateFileStatus(file.id, { status: 'processing', progress: 0 });
            });
        }

        // 启动Worker
        function startWorkers() {
            // 创建指定数量的Worker
            for (let i = 0; i < UPLOAD_CONFIG.maxConcurrentWorkers; i++) {
                createWorker();
            }
        }

        // 创建Worker
        function createWorker() {
            const worker = new Worker(window.workerBlobUrl);

            // 监听Worker消息
            worker.onmessage = function (e) {
                handleWorkerResult(e.data);
            };

            worker.onerror = function (error) {
                updateStatus(`Worker错误: ${error.message}`, 'error');
                worker.terminate();
                state.activeWorkers--;
                checkAllTasksCompleted();
            };

            state.workers.push(worker);
            state.activeWorkers++;

            // 立即分配任务
            assignTaskToWorker(worker);
        }

        // 分配任务给Worker
        function assignTaskToWorker(worker) {
            if (state.taskQueue.length === 0) {
                // 没有任务了，终止Worker
                worker.terminate();
                state.activeWorkers--;
                checkAllTasksCompleted();
                return;
            }

            // 从队列获取任务
            const task = state.taskQueue.shift();
            worker.postMessage(task);
        }

        // 处理Worker返回的结果
        function handleWorkerResult(result) {
            const { fileId, chunkIndex, hash, error } = result;

            if (error) {
                updateFileStatus(fileId, { status: 'error', error });
                updateStatus(`文件 ${getFileName(fileId)} 处理错误: ${error}`, 'error');
                return;
            }

            // 更新块结果
            const fileData = state.fileChunks.get(fileId);
            if (!fileData) return;

            fileData.results.set(chunkIndex, hash);
            fileData.completedChunks++;

            // 计算进度
            const progress = Math.round((fileData.completedChunks / fileData.total) * 100);
            updateFileStatus(fileId, { progress });

            // 检查是否所有块都已处理完成
            if (fileData.completedChunks === fileData.total) {
                // 合并所有块的哈希得到最终哈希
                const finalHash = mergeChunkHashes(fileData.results, fileData.total);
                updateFileStatus(fileId, { hash: finalHash });
                updateStatus(`文件 ${getFileName(fileId)} 哈希计算完成，准备上传`);

                // 开始上传文件
                uploadFile(fileId, finalHash);
            }

            // 给当前Worker分配新任务
            const worker = state.workers.find(w => w !== null);
            if (worker) {
                assignTaskToWorker(worker);
            }
        }

        // 合并块哈希
        function mergeChunkHashes(results, totalChunks) {
            // 按块索引排序并合并哈希
            let hash = '';
            for (let i = 0; i < totalChunks; i++) {
                hash += results.get(i);
            }

            // 对合并后的字符串再计算一次哈希，得到最终结果
            return md5(hash);
        }

        // 简单的MD5实现（用于合并哈希）
        function md5(str) {
            // 实际项目中可以使用成熟的库如spark-md5
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // 转换为32位整数
            }
            return Math.abs(hash).toString(16).padStart(32, '0');
        }

        // 上传文件
        function uploadFile(fileId, fileHash) {
            const file = state.files.find(f => f.id === fileId);
            if (!file) return;

            updateFileStatus(fileId, { status: 'uploading' });
            updateStatus(`开始上传文件: ${file.name}`);

            if (UPLOAD_CONFIG.simulateUpload) {
                // 模拟上传过程
                simulateUpload(fileId);
            } else {
                // 实际上传实现
                // 这里应该是你的实际上传逻辑，如使用fetch或axios
            }
        }

        // 模拟上传
        function simulateUpload(fileId) {
            const file = state.files.find(f => f.id === fileId);
            if (!file) return;

            // 模拟上传进度
            let progress = file.progress;
            const interval = setInterval(() => {
                progress += Math.random() * 10;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                    updateFileStatus(fileId, { status: 'completed', progress: 100 });
                    updateStatus(`文件 ${file.name} 上传完成`);
                }
                updateFileStatus(fileId, { progress });
            }, 500);
        }

        // 检查所有任务是否完成
        function checkAllTasksCompleted() {
            if (state.activeWorkers === 0 && state.taskQueue.length === 0) {
                updateStatus('所有文件处理完成!', 'success');
                state.isUploading = false;
                elements.startButton.innerHTML = '<i class="fa fa-play mr-2"></i>开始上传';

                // 检查是否所有文件都已完成
                const allCompleted = state.files.every(f =>
                    f.status === 'completed' || f.status === 'error'
                );

                if (allCompleted) {
                    elements.startButton.disabled = false;
                }
            }
        }

        // 辅助函数: 获取文件状态文本
        function getFileStatusText(status) {
            const statusMap = {
                pending: '等待上传',
                processing: '计算哈希中',
                uploading: '上传中',
                completed: '已完成',
                error: '出错'
            };
            return statusMap[status] || status;
        }

        // 辅助函数: 获取状态颜色类
        function getStatusColorClass(status) {
            const colorMap = {
                pending: 'text-neutral',
                processing: 'text-primary',
                uploading: 'text-primary',
                completed: 'text-secondary',
                error: 'text-danger'
            };
            return colorMap[status] || 'text-neutral';
        }

        // 辅助函数: 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 辅助函数: 获取文件名
        function getFileName(fileId) {
            const file = state.files.find(f => f.id === fileId);
            return file ? file.name : '未知文件';
        }

        // 更新上传状态文本
        function updateStatus(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const typeClass = {
                info: 'text-neutral',
                success: 'text-secondary',
                error: 'text-danger'
            }[type] || 'text-neutral';

            const statusEntry = document.createElement('div');
            statusEntry.className = `mb-1 ${typeClass}`;
            statusEntry.innerHTML = `<span class="opacity-70">[${timestamp}]</span> ${message}`;

            elements.uploadStatus.appendChild(statusEntry);
            elements.uploadStatus.scrollTop = elements.uploadStatus.scrollHeight;
        }

        // 初始化应用
        document.addEventListener('DOMContentLoaded', init);

        // 清理资源
        window.addEventListener('beforeunload', () => {
            // 终止所有Worker
            state.workers.forEach(worker => worker.terminate());

            // 释放Blob URL
            if (window.workerBlobUrl) {
                URL.revokeObjectURL(window.workerBlobUrl);
            }
        });
    </script>
</body>

</html>