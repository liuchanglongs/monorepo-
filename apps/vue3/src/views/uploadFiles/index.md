- https://juejin.cn/post/7475978280839954468#heading-17
  为啥不用webworker

多个文件同时上传：

1. 状态管理

- 整体： files(文件列表)、workers（开启的线程）、fileTaskQueue(文件切片队列)
- 文件信息：id、file(文件)、status（pending, uploading, paused, completed, error）、progress（进度条）、seed(上传速率)、chunks（切片信息）、totalChunks（总切片数）、worker（当前处理的worker）
- 每个切片的类型

fileList: 上传状态
维护每个文件的上传状态（等待、上传中、暂停、完成、错误）； 实时更新进度条和状态文本；提供直观的操作按钮（暂停 / 恢复）
维护每个文件的切片的上传状态（已上传、未上传）

架构核心组件
任务生产者：负责拆分文件：读取待上传文件列表，将每个文件拆分为 “数据块子任务”，加入共享任务队列。
共享任务队列：每个文件都有自己的， “分块 Hash 计算子任务”，支持线程安全的 “取任务”（避免并发竞争）。
线程池: 管理固定数量的工作线程（如 3 个，匹配 “同时上传 3 个文件” 的需求），线程空闲时从队列取任务。
结果合并器: 收集每个文件的所有分块 Hash 结果，按索引排序后合并为最终 Hash，触发后续上传逻辑。

任务调度函数：
分配 webworker, 每个任务先分配一个worker,多余的分配给文件大的
分配 请求, 每个任务先分配一个请求, 多余的分配给文件大的

1. 预先创建web worker：快速启动 Web Worker 执行任务(这里3个)
1. 为每个上传的文件分配一个或多个 Web Worker：一个文件分配3个webworker， 多个文件按照顺序分配1个，其余的等待

1. Web Worker 分配策略：

- 使用固定大小的 Worker 池（最多 4 个），避免创建过多 Worker 导致资源耗尽
- 采用任务队列机制，当 Worker 空闲时自动处理队列中的下一个任
- 每个文件上传任务会占用一个 Worker，直到完成或暂停

2. 边切片边上传机制：

- 切片和上传并行处理，一个切片处理完成后立即开始上传
- 上传过程中实时计算进度并更新 UI
- 每个切片单独处理和上传，便于实现断点续传

3. 暂停 / 恢复功能：
   暂停时会释放 Worker 资源，让其处理其他任务
   恢复时将任务重新加入队列，等待空闲 Worker
   保持已完成的切片状态，恢复后从断点继续上传
   优化：Worker 始终在池中循环利用，即使任务暂停，Worker 也不会被销毁，而是转为 “空闲” 状态等待新任务（可能是恢复的原任务或新任务）。
4. 状态管理：
   维护每个文件的上传状态（等待、上传中、暂停、完成、错误）
   实时更新进度条和状态文本
   提供直观的操作按钮（暂停 / 恢复）

   内存消耗的问题：切片的chunk有必要传回Blob？避免双倍的内存开销
   不用的浏览器怎么启用合适的 worker线程数
